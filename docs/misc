
\d .taq
/ -------------------------------------------------------------------------------------------------------------------------------
/   prefix: prefix for all TAQ objects
/   dbname: database directory name for TAQ db (created from source kdb+ tables)
/   define: given path, e.g. /dat/cost/db/taq, define internal TAQ database dates and in-memory tables
/   source: given path, e.g. /dat/taqqdb, define external TAQ source database dates & dirs, sym & mas defined at root
/ mapdaily: given date, map in daily summary information, or empty table from last date
/ maptrade: given date, map in daily trades, or empty table from last date
/ mapquote: given date, map in daily quotes, or empty table from last date
/ lastdate: given date, return latest date on or just before given date where TAQ data is available
/   master: given date, return latest daily summary of symbols traded, along with cusip, when-issued flag, exchange code and name
/  skipday: return vector of TAQ holidays encountered so far, as well as early close, late open or some outlier condition
/ -------------------------------------------------------------------------------------------------------------------------------
prefix:dbname:`taq
dbpath:{.sys.dbpath[x]dbname}
define:{if[any x~/:(`;`:;::); x:dbpath 1b]; date::.sys.part x; path::x; .[` sv ``,prefix;();,;x prefix];}
source:{if[any x~/:(::;();`;`:); x:.sys.source`taq]; `..sym`..mas set'x`sym`mas; sourcedate::union/[sourcedates::.sys.parts x]}
`mapdaily`maptrade`mapquote set'.sys.mapdate[system"d"]@'(` sv prefix,)'[`daily`trade`quote];

lastdate:{
 if[0<count d:@[{date};0;()]; :d d bin x];                                             /use context dates if defined from original path
 if[not (t:` sv prefix,`daily)in .sys.pt[]; '"TAQ data not defined"];                  /else check that daily TAQ partitions exist
 d:except/[`. ./:(1#`date;prefix,`holiday)];                                           /use global date partition except TAQ holidays
 while[not null x:d d bin x; if[count distinct`:. .(`$string x;t;`sym); :x]; x-:1]; x} /if empty partition, decrement date, re-test

master:{
 d:lastdate x;
 t:1!select sym,date:d,allvolume,regvolume,vwap,opentime,open,opensize,closetime,close,closesize,vol,spread,logspread from mapdaily d;
 m:select last cusip,last wi,last ex,last name by sym from`. . `taq`master where not sym like".*",date<=d,date=(max;date)fby sym;
 t:t lj update m:1b from m;
 s:exec{`$raze"."vs x}'[string sym]!sym from t where not m,sym like"*?.?*"; /check if sym without "." is in master
 s:(key[s]inter exec sym from t)_s;                                         /don't remap if sym w'out "." also exists
 (delete m from t)lj update s sym from select from m where sym in key s}    /remap master to include "." for match

skipday:{raze@[`..taq `day`holiday;0;{exec date from x where early|late|outlier}]}

/ ----------------------------------------------------------------------------------------------------------------------------
/ utilities for determining available TAQ date ranges without loading source database directly into active q session
/ TAQ source data is located across subdirectories, an NFS location points to a directory which contains par.txt.
/ par.txt has a list subdirectories which contain the dates available, e.g. /dat/taqqpar/0, /dat/taqqpar/1, ..
/ when TAQ is updated, these subdirs are changed in place, may be in an incomplete state when a new date is detected
/ (as of this writing, partition /0 contains dates from 1993.08.01, while 1/ & 2/ contain dates from 2011.08.05)
/ ----------------------------------------------------------------------------------------------------------------------------
/      dirs: return directories for a given date (source function must establish "sourcedates" map)
/ datecheck: return given date if valid TAQ date, else signal error (wrong datatype or invalid date)
/      rows: count source trade,quote rows for each partition for a given date
/      data: retrieve trade/quote date by each trade's sub-partition for given date and symbol(s)
/     trade: given date & symbol(s), return source TAQ trade data
/     quote: given date & symbol(s), return source TAQ quote data
/  symcount: return symbols and counts for given table(trade or quote) and date
/  tradesym: return symbols and trade count for given date
/  quotesym: return symbols and quote count for given date
/       sym: return symbols and count of trades & quotes for given date
/     ready: return true if complete data found given w-TAQ dir, d-date, m:minutes (no file changes in this interval)
/      wait: wait until TAQ data is complete for previous weekday given w:TAQ dir, u:until time, m:minutes to sleep
/ ----------------------------------------------------------------------------------------------------------------------------
dirs:{` sv'where[x in/:sourcedates],'`$string x}
datecheck:{if[$[t:-14h=type x; not x in sourcedate; 1b]; '"invalid TAQ date: ",$[t;string x;"(not date datatype)"]]; x}
rows:{k!@[{count x`};;0]each k:raze over{` sv x,y,z}'[where x>=first each sourcedates]'[`$string x]'[`trade`quote]}
data:{[t;d;s]raze{[t;s;p]select from p t where sym in s}[t;s]peach dirs d}
trade:data`trade
quote:data`quote
symcount:{1!(`sym,(`trade`quote!`trades`quotes)x)xcol raze{([]u;1_deltas(s?u:distinct s),count s:.[{x . y};(y;x,`sym);0#`])}'[x;dirs datecheck y]}
tradesym:symcount`trade
quotesym:symcount`quote
sym:{`sym xasc uj/[symcount'[`trade`quote;x]]}

ready:{[w;d;m]                                                          /w-TAQ dir, d-date, m-minutes (e.g. 00:05 or 5)
 source w; s:string d;                                                  /check TAQ partitions
 if[d>last sourcedate; .sys.msg"No TAQ data for ",s;            :0b];   /return false if date beyond end
 if[any 0=n:rows d;    .sys.msg"TAQ data for ",s," incomplete"; :0b];   /return false if some empty sub-partition(s)
 n:count raze{system" "sv(.sys.which`find;1_string y;"-type f -mmin";string neg x)}["i"$"u"$m]'[key n];
 $[n;[.sys.msg"TAQ update for ",s," may still be running"; 0b]; 1b]} /return false if some file changed within m minutes

wait:{[w;u;m] r:0b; d:{x-$[3>d:x mod 7;d+1;1]}.z.D; while[ $[.z.T>u;0b;not r:ready[w;d]m]; .sys.sleep m]; r}

/ ---------------------------------------------------------------------------------------------------------------------------------------
/ variables & functions below are used to update TAQ database from original kdb+ tables
/ ---------------------------------------------------------------------------------------------------------------------------------------
/      gzip: blocksize & compression level used with file/dir to compress trades & quotes
/  dayrange: return start & end time(s) of day session given date(s), or given both table & date(s) (table set to taq.day if not given)
/   dayrack: given trading day range, e.g. 09:30 16:00, return vector of minutes, starting pts for bins
/       day: read config file -> table of early close, late open and outlier days in TAQ data
/ duplicate: find non-distinct elements
/  symcheck: check taq partition symbols: if `p attr set return list, else signal error indicating symbols out of sequence
/     round: round 4-byte float to 8-byte float to match original taq price (reported with 4 decimals)
/ ---------------------------------------------------------------------------------------------------------------------------------------
gzip:(;17;2;6)
dayrange:{$[type x; [d:x;t:`..taq.day]; [t:x 0;d:x 1]]; exec(09:30^open;16:00^close)from(1!select date,open,close from t)$[0>type d;d;([]date:d)]}
dayrack:{a+til"i"$x[1]-a:x 0}
day:{1!("DUUBBB*";1#"\t")0:` sv x,`day.txt}
etf:{("S*";1#"\t")0:` sv x,`etf.txt}
duplicate:{distinct x where not(x?x)=til count x}
symcheck:{$[`p=attr s:x . y,`sym; distinct s; '` sv(string[y]," sym not part'd: ",1_string x;"out-of-sequence symbol: ",", "sv string .sys.partfail s)]}
round:{("i"$f*x)%f:10000 1000 100f[0N 1000 10000e bin x]}

/ ----------------------------------------------------------------------------------------------------------------------------
/ functions for filtering, flagging and summarizing trades
/ ----------------------------------------------------------------------------------------------------------------------------
/    dupfind: find rows where price,exchange,size repeated for specific condition codes, e.g. "Q" prints matched by "O" prints
/   omitflag: add flag for trades to omit: set true if duplicate of open/close print
/ timefilter: allow O,Q 250ms before 09:30, else 09:30-3:59p, except for closing prints which are not restricted by end time
/   openpick: if NYSE, use cond="O" & ex="N" if found, else first of allowable: cond in " FQ"
/  closepick: use largest cond="6" print if found, else cond="M"
/  openclose: set open & close flags per symbol for a day's trades
/  tradeflag: add flags for open,close, for omitting trade, for ok condition, regular day and combinations
/     trades: round price, add flags indicating within trading day, regular trade, close print
/   tradesum: summary calculations by symbol over entire day: volumes, vwap, open & close
/    minvwap: calculate minute vwaps
/    volcalc: std dev of 1-minute vwap returns, forward filled to all minutes(in bp, scaled to daily from minutely)
/   tradeday: daily summary calcs & volatility given trading day range,trade data w'extra indicator cols
/ ----------------------------------------------------------------------------------------------------------------------------
dupfind:{[t;c]i[0]{where x in y}.(`sym`price`size`ex#t)i:where'[c=\:t`cond]}
omitflag:{j:raze dupfind[x]'[("QO";"M6")]; update omit:1b from x where i in j}

timefilter:{[r;c;t]t within(?[c in"OQ";r[0]-00:00:00.250;r 0];?[c in"M6";0W;r[1]-00:01:00.0])}

openpick:{[m;e;c;s;t]                            /m:cutoff minutes, e:exchange, c:condition, s:size, t:time
 a:t i:first where c in" FQ";                    /find time & row of 1st qualifying trade aside from an "O" print
 i:$[-1<n:o first where "N"=e o:where c="O"; n;  /use an NYSE opening print if found
    0=count o; i;                                /no opening print, use 1st qualifying trade if found
    1=count o; $[t[o@:0]>0W^m+a; i; o];          /only one open, use unless more than m minutes from 1st qualifying trade, e.g. late arca open
    o first idesc s o@:where x<m+min x:t o];     /drop any opens more than m minutes after earliest one, then pick one w'largest size
 @[count[c]#0b;$[null i;();i];:;1b]}             /return boolean for all trades with open marked true

closepick:{[c;s] @[count[c]#0b; $[null i@:first idesc s i:where $[max i:c="6";i;c="M"];();i]; :; 1b]} /largest size "6" print, use "M" if no "6"

openclose:{[r;t]
 update openflag:{openpick . x}(00:01;ex;cond;size;time), closeflag:{closepick . x}(cond;size) by sym
   from t where {timefilter[x;y;z]}[r;cond;time],not omit}

tradeflag:{[r;t]
 update regular:include&dayflag from                                    /regular:true if includable condition and regular session
 update include:not[omit]&?[cond in" FI";1b;not[dayflag]&cond="T"]from  /include:true if trade condition amongst allowed set
 update dayflag:time within"t"$r from openclose[r]omitflag t}           /dayflag:true if during regular trading session

tradefilter:{select sym,time,{round x}price,"j"$size,stop,cond,ex from x where all(corr=0;price>0;size>0;not null sym)}
trades:{[r;t]select sym,time,price,size,stop,cond,ex,openflag,closeflag,omit,dayflag,include,regular from tradeflag[r]tradefilter t}

minvwap:{[t]select v:size wavg price by sym,time.minute from t where regular}
volcalc:{[r;t]f:10000*sqrt count m:dayrack r; exec f*dev -1+1_ratios fills v by sym from cross[select distinct sym from t;([]minute:m)]#minvwap t}

tradesum:{[r;t]
 select sym,allvolume,regvolume,vwap,opentime,open,opensize,closetime,close,closesize,vol:{volcalc[x;y]z}[r;t;sym],trades,ti from
 lj/[(select allvolume:sum?[omit;0;size], regvolume:sum?[regular;size;0], vwap:?[regular;size;0]wavg price, ti:first i, trades:count i by sym from t;
      select  opentime:last time,  open:last price,  opensize:last size by sym from t where openflag;
      select closetime:last time, close:last price, closesize:last size by sym from t where closeflag)]}

/ ----------------------------------------------------------------------------------------------------------
/ variables & functions for quotes: get best bid/offer across exchanges, time-weighted average spread, etc.
/ ----------------------------------------------------------------------------------------------------------
/  bestlast: zero out the sizes and set nobid/noask values in final quote of the day for each exchange
/   bestfix: adjust bid/ask if no size or bid>ask to n/a values
/ bestquote: find best bid/ask and corresponding size across exchanges
/ logspread: log of spread or 0.0001 if greater, preserve nulls
/    spread: calculate time-weighted spread over given range(the regular trading session) using best bid/ask
/  bestcalc: for single name, get best bid/offer, filter outliers, get average spread, counts
/ ----------------------------------------------------------------------------------------------------------
noask:0we   /constants used for no valid ask/bid
nobid:0Ne   

bestlast:{@[x;last'[get group x`ex];@[;`bid`ask`bsize`asize;:;nobid,noask,0 0i]]}

bestfix:{
 {@[x;`bid`ask;@[;where x[`bid]>x`ask;:;];nobid,noask]}
 update{?[not x;noask;x]}ask from update bid:{?[not x;nobid;y]}[bsize;bid],ask:?[not asize;0e;ask]from x}

bestquote:{
 j:(i:group e){where deltas x,y}'count e:x`ex;
 t:(x`time; p; sum((0i,'x[i;`bsize])@'j)*b=\:p:max b:(nobid,'x[i;`bid])@'j;
            p; sum((0i,'x[i;`asize])@'j)*a=\:p:min a:(noask,'x[i;`ask])@'j);
 c:`time`bid`bsize`ask`asize; flip c!$[count x;t;type'[x c]$t]}

logspread:{@[log .0001|x;where null x;:;0n]}

spread:{[r;t;s;q]
 s:(s;logspread s;q); n:i[1]-first i:@[t bin r;0;0|];
 a:$[n>0; (1_deltas @[t i;0;|;r 0],r 1)wavg/:s@\:i:i[0]+til n+1; (n=0)&r[1]>t i@:0; "f"$s@'i; 0n 0n 0n]; @[a;1;exp]}

bestcalc:{[q;s]  /q:quotes, s:dictionary with sym, starting index, number of quotes
 q:bestquote bestfix bestlast select from q where i within sums@[s`qi`quotes;1;-;1]; /find best bid/ask at each row
 q:select from q where(ask-bid)within(0;2|bid);                                      /drop if bid>=ask, spread > max of $2 or bid
 s:@[s;`best;:;count q:q where differ delete time from q];                           /rows where best bid/ask or size change
 s:@[s;`spread`logspread`quotesize;:;spread[s`opentime`closetime]. exec(time;ask-bid;bsize&asize)from q];  /time-wt'd spread,logspread,size
 (s;q)}

/ ----------------------------------------------------------------------------------------------------------------------------
/  functions for calculating threshold dollar amounts for order routing, creating daily file, etc.
/ ----------------------------------------------------------------------------------------------------------------------------
/   routedate: given window & date, returns window of dates w'daily data ending on/before supplied date (null -> .z.D)
/  routefloor: if vwap < $1000, calculate minimum threshold based on 100 shares, allowing vwap to increase by 10%
/   routeskip: given run date and tab-delimited text file, return table of sym & note of TAQ symbols to exclude
/   routeflag: set "ok1" if valid symbol, vwap above minimum, positive spread & threshold,not over ceiling,sufficient qty
/              set "ok2" if valid symbol, vwap above minimum, non-zero spread below max
/              valid symbol if no ".", or with 1-letter suffix except .U (unit) and not test symbol, e.g. ZVZZ.T
/   routecalc: calculate threshold values from daily summary of taq data
/ routeticker: map TAQ sym to Bloomberg ticker, overwrite sym's w'different format, e.g. BRK.B -> BRK/B, CMCS.A -> CMCSA
/   routefile: return 4 file names given dir and system timestamp: 2 for generic timestamp & threshold, 2 for history/
/   routewarn: check if data for previous weekday, add warning message if not found (holiday or TAQ missing)
/   routerack: create rack with row for all dates and symbols
/  routevalue: create value: v, change: c, flag: ok from either threshold or spread
/  routecount: count TAQ symbols, number of valid, up,down,same,maximum,added,dropped
/   routedist: distribution of values in 20%, 40%, ..100% of maximum threshold1 or spreadbp
/    routesum: summary report of thresholds or spreads during window, e.g. past week
/    routecsv: return 4 arrays: timestamp, thresholds w'spreads & volume, thresholds w'spreads, full detail in csv format
/    routemsg: email summary message comparing counts,up,down, etc. of last week's worth of thresholds
/   routemail: send email to addresses, attach csv data for timestamp, thresholds and detail
/routeexclude: read exclusion file under error trap, return table of excluded symbols and notes, print if non-empty
/    routejob: given dictionary of job arguments, run threshold calcs, set flags, create summary report, save csv files
/       route: takes dictionary of job parameters, loads TAQ db if not already loaded, creates files and prints/emails report
/   loadroute: build routing files as part of loader job, runs after load completes using default route job parameters
/ ----------------------------------------------------------------------------------------------------------------------------
routedate:{[n;d]neg[n&count r]#r:{x where x<=y}[`. `date;.z.D^d]except skipday[]}
routefloor:{[t]delete f from update threshold1|f,threshold2|f from update f:"j"$vwap*110 from t where ok1,vwap<1000}
routeskip:{[d;f]t:("SDB*";1#"\t")0:f; select sym,note from(select by sym from t where date<=d)where exclude}

routeflag:{[q;v;m;t]   /q:min qty, v:min vwap, m:max spread, t:table of calcs
 update
  ok1:all(ok1; vwap>=v; spread>0; threshold1>=0; qty1>=q), /threshold ok if within limits
  ok2:all(ok1; vwap>=v; spread>0; spreadbp<=m)from         /spread ok if positive, not over 500bp
 update
  spreadbp:10000*spread%vwap,
  ok1:{(not x like"*.*")|(x like"*.[A-T,V-Z]")&not x like"Z?ZZ.T"}sym from t}  /exclude test sym, .U or multi-char suffix

routecalc:{[x;d]
 c:`date`sym`regvolume`vwap`vol`spread!`date`sym`regvolume`vwap`vol,$[x`logspread;`logspread;`spread];                            /column expressions
 t:?[`taq.daily;((in;`date;enlist d);(>;`trades;0));0b;c];                                                                        /taq.daily retrieval
/t:@[t;`qty1`qty2;:;exec regvolume*/:{xexp[x*4%3]5%3}{?[y>.00001;(0|z-x)%y;0]}[1667*spread%vwap;vol xexp 1.2]'[x`bp1`bp2]from t]; /model:qty from cost bp
 t:@[t;`qty1`qty2;:;exec regvolume*/:{xexp[x*1%0.379]1%0.46}{?[y>.00001;(0|z-x)%y;0]}[1667*spread%vwap;vol xexp 1.17]'[x`bp1`bp2]from t];
 t:@[t;`liquid1`liquid2;:;exec vwap*/:{[a;c;b]x*x:(neg[b]+sqrt(b*b)-4*a*c)%2*a}[vwap%1e6;neg x`sscap]'[-/[x`sscap`cap]%sqrt'[(qty1;qty2)]]from t];
 t:update volumecap:vwap*regvolume*x[`volumepct]%100 from t; m:1e6*x`cap;     /overall volume cap, cap in millions
 t:update threshold1:"j"$volumecap&?[liquid1<m;vwap*qty1;liquid1],
          threshold2:"j"$volumecap&?[liquid2<m;vwap*qty2;liquid2]from t;      /use cost model qty if liquid threshold<cap(in millions)
 routefloor routeflag[x`qty;x`minvwap;x`maxspread]t}                          /add flags ok1:true if thresholds in effect, ok2:true if spread ok

routeticker:{[t]
 m:2!raze{select date,sym,ticker from first[.stock.taqbloom x]where not sym=sym^ticker}peach distinct t`date;
 delete ticker from update sym:ticker from .sys.denum[t]lj m where not null ticker}

routefile:{[w;p](` sv w,)'[s],` sv'(w,`history),/:(` sv(`$string .sys.ymd p),)'[s:`timestamp.csv`threshold.csv`route.csv]}
routewarn:{$[x=p:{x-$[(m:x mod 7)within 1 2;m+1;1]}.z.D; (); ("Warning: TAQ data not used or not available for ",string .sys.weekday p;"")]}
routerack:{(exec([]distinct date)cross([]distinct sym)from x)#`date`sym xkey update taq:1b from x}
routevalue:{[t;b]update c:?[p;c;c 0N]from update p:prev ok,c:deltas v by sym from update v:?[b;threshold1;spreadbp],ok:?[b;ok1;ok1|ok2]from t}
routecount:{select sum taq,sum ok,up:sum 0<c,down:sum 0>0^c,add:sum ok&not p,drop:sum p&not ok by date from x}
routedist:{[n;t]k:`$string[(100%n)*j:1+til n],'"%"; exec k!count'[group 1|n&ceiling v%max[v]%n]j by date:date from t where ok}

routesum:{[t;n;b]  /t:data table, n:number of bins, b:1-threshold, 0-spreadbp
 d:1<count r:update .sys.weekday date from routecount[t]lj routedist[n]t:routevalue[t]b;
 r:enlist reverse d _ r;
 s:@[-8 8#\:exec sym from select[<c]sym from t where date=last date,ok,p;0;reverse];
 s:distinct'[s,@[-8 12#\:exec sym from select[<v]sym from t where date=last date,ok;0;reverse]];
 g:reverse d _exec sym!?[ok;v;v 0N]by date:date from t where sym in raze s;
 v:s#\:{n:count x; g:` xcol([]n#()); $[n;x,'g;g]}get g;
 r,(update .sys.weekday date from key g)!/:"j"$v}

routecsv:{[p;t]","0:'
 (flip 1#'`date`time`taqdate!(.sys.ymd p;"v"$p;.sys.ymd max t`date);
  select sym,threshold:?[ok1;threshold1;0],spread:spreadbp,regvolume from t where date=max date,ok1|ok2;
  select sym,threshold:?[ok1;threshold1;0],threshold2:?[ok1;threshold2;0],spread:spreadbp,regvolume from t where date=max date,ok1|ok2;
  select[<sym]from t)}

routemsg:{[e;f;t]
 str:{.Q.S[30 200;0j;x],1 0#""}; t:.sys.denum routerack t;
 s:`Threshold`Increase`Decrease`Largest`Smallest`Spread`Increase`Decrease`Largest`Smallest;
 s:raze 6#str'[s xcol'raze routesum[t;5]'[10b]];
 if[count e; s,:str 1!`Exclusion`Note xcol update`$note from e];
 routewarn[exec max date from t],s,str 0N 1#`,(`$"Files:"),`$1_'string f}

routemail:{[e;f;m;v]v:((last` vs)'[3#f],`detail.csv;"cccc";v); .sys.mail[e;();();"Trade analysis";"Daily order thresholds and spreads";m;v]}

routeexclude:{[d;f]
 e:flip`sym`note!(`;());                                                                           /define empty exclusion table
 if[not .sys.nullpath f; e:.[routeskip; (d;f); {[e;x] -2"ERROR reading exclusion file:",x; e}e]];  /if exclusion file defined, attempt to read
 if[n:count e; .sys.msg(n;"symbol(s) excluded from routing file:\n"); -2 .Q.S[100 100;0]e; -2""];  /print any active exclusions
 e}

routejob:{
 if[not all 0<x`cap`sscap`bp1`bp2;'"bad threshold arg(s)"];
 f:routefile[x`target]p:.z.P;                                                                  /path of generic and history/ timestamp & threshold files
 t:routecalc[x]routedate[6]x`date;                                                             /calculate threshold for date and week+1 day back
 e:routeexclude[.z.D;x`exclude];                                                               /get any exclusions as of run time if exclude file exists
 t:delete from t where sym in e`sym;                                                           /remove excluded symbol(s)
 if[x`bloomticker; t:@[routeticker;t;{[t;x] -2"Error mapping to Bloomberg ticker: ",x; t}t]];  /use Bloomberg tickers instead of TAQ symbol
 m:.[routemsg;(e;f;t);"Error creating summary report"];                                        /msg with summary counts,distribution,largest,smallest, etc
 f 0:'count[f]#3#v:routecsv[p;t];                                                              /csv for timestamp, thresholds & detail
 $[count string x`mail; routemail[x`mail;f;m;v]; -2 m]}                                        /email msg if non-null address(es), else print to stderr

route:{
 if[not`taq.daily in .sys.pt[];.sys.qload .sys.dbtarget[dbname;x`local;x`taq]];
 if[x`bloomticker; @[.bloom.define;.sys.dbtarget[.bloom.dbname;1b]x`bloom;{-2"Error defining Bloomberg data: ",x;}]];
 routejob x}

loadroute:{
 r:-60 90+"v"$t:x`routetime; while[.z.T within r; .sys.msg("Waiting to write routing files, too close to cutoff time";t); .sys.sleep 10];
 .sys.msg"Building order routing files"; @[route; @[arg`route;`taq;:;x`target]; {-2"ERROR: creating order routing files & report\n",x}]}

/ --------------------------------------------------------------------------------------------------------------------------------
/  functions to read in trades & quotes from TAQ and create new database w'trades & flags, best bid/ask quotes
/ --------------------------------------------------------------------------------------------------------------------------------
/  daycheck: check that source sub-partition tables are partitioned by symbol, no symbol crosses sub-partition, warn if not sorted
/     renum: denumerate symbols from original TAQ sym vector and re-enumerate in new database
/    memory: log memory use before and after garbage collection
/   symrows: given partitioned list of symbols, return 3-element list: (distinct symbols; starting index; no. of rows)
/  saverows: create 3-col table from partitioned list of quote symbols: sym, qi-first index, quotes-no. of rows
/ savetrade: save trades to gzip compressed directory, initialize via set command if dir not found, else append
/ savequote: given a block of symbols, calculate best bid/ask and time-weighted spread, create/append to daily table
/  savepart: handles sub-partitions with day, calculating best bid/ask with threads on blocks of symbols
/  saveattr: given symbols w'trade & quote counts, write sym vector, partition, compress, add to trade,quote table
/ savecheck: verify that trade & quote partition counts per symbol match summary, print summary msg on counts
/   savebid: save bid,ask occuring on/before each trade
/   savesym: enumerate a day's symbols, create partitioned sym vector for trades & quotes, add bid,ask, check counts
/   savedir: gives working directory paths for daily summary, trade and quote tables
/   saveday: loop through TAQ sub-partitions, filter trades, summarize, save best bid/ask quotes and spread
/ savetable: save in-memory tables from configuration files, optionally save TAQ master and holiday vector if updating database
/ saverange: create working directory, copy enumeration vector, save each day, write in-memory tables
/ --------------------------------------------------------------------------------------------------------------------------------
daycheck:{[d]
 a:raze'[s:symcheck'[z:dirs d]'[t:`trade`quote]]; f:{-2 .Q.S[30 80;0j;x]; -2"";}; dt:string d;
 v:update z part from ungroup raze{s:.sys.partfail y; z; ([]table:x; sym:s; part:s{where x in/:y}\:z)}'[t;a;s];
 if[count v; f v; '"symbol found in more than one table partition on ",dt];
 v:raze t{ungroup([]table:x; sym:y; part:til count y)}'s;
 v:delete from v where 1=(count distinct@;part)fby sym;
 if[count v; f v; '"symbols not aligned across same trade & quote partition on ",dt];
 v:update z part from raze{([]table:x; part:where not{x~asc x}'[y])}'[t;s];
 if[count v; f v; .sys.msg"Warning: symbols not sorted in one or more partitions on ",dt];
 if[count v:t where not {x~asc x}'[a]; .sys.msg"Warning: symbols not sorted overall for table: ",sv[", ";string v]," on ",dt];
 s}

renum:{.sys.sym[x;prefix].sys.denum y}
memory:{.sys.memory m:1_string ` sv x,y; .Q.gc[]; .sys.memory m," after gc"}
symrows:{(u; i; 1_deltas(i:x?u:distinct x),count x)}
saverows:{flip`sym`qi`quotes!symrows x}
savetrade:{[v;t] $[()~key v; gzip[v]set t; .[v;();,;t]]}

savequote:{[v;z;q;s]
 q:bestcalc[q]peach s; s:q[;0]; q:q[;1];
 if[b:()~key v; gzip[v]set first q]; .[v;();,;]'[b _q];
 memory[z]`quote; delete opentime,closetime from s}

savepart:{[b;r;m;z;zi]    /b:syms per block, r:day range, m:map of table dirs, z:taq subdir; zi:i'th subdir
 .sys.msg "Loading partition: ",1_string z;
 savetrade[m`trade]delete sym from t:trades[r]z`trade; t:tradesum[r]t; memory[z]`trade; /save filtered trades and summarize
 q:z`quote; s:saverows q`sym; q:delete sym,cond from q;                                      /find start & count of quotes by symbol
 s:update opentime|r 0,(0W^closetime)&r 1 from s lj 1!select sym,opentime,closetime from t;  /get symbol-specific open & close times
 s:n#raze savequote[m`quote;z;q]'[b cut$[n:count s;s;1#s]];                                  /save quote blocks, dummy arg if no quotes
 select[<sym]sym,allvolume,regvolume,vwap,opentime,open,opensize,closetime,close,closesize,
       vol,spread,logspread,quotesize,0^trades,0^quotes,0^best,zi,ti,qi
   from uj/[`sym xkey'(t;s)]}

saveattr:{[s;m;x]                                                         /s:symbols, m:paths, x:`trade/`quote
 mem:memory{hsym`$x last where not x like""}"/" vs string m@:x;           /call memory utility w'path set to table name
 s:select[<([]zi;?[x=`trade;ti;qi])]sym,n:?[x=`trade;trades;best]from s;  /get counts ordered by partition and original start index
 (f:` sv m,`symtemp)set 0#s`sym; {.[x;();,;y#z]}[f]'[s`n;s`sym];          /initialize, append symbols in parts (to conserve memory)
 .[f;();`p#]; mem`symtemp; -19!f,gzip` sv m,`sym; mem`sym;                /partition, free memory, compress, free memory
 hdel f; @[m;`.d;`sym union]}                                             /remove temp symbol file, add sym col to file
 
savecheck:{[d;m;s]
 n:0^uj/[{1!flip(`sym,y)!symrows[x`sym]0 2}'[m@:`trade`quote;`trades`best]];
 e:exec sym from (1!select sym,trades,best from s where 0<trades|best)=n where not trades&best;
 if[count e; '"Mismatch between TAQ trade/quote counts saved for: ",", "sv string e];
 if[all 0=n:sum'[s`trades`quotes`best]; :.sys.msg"Warning: no trades or quotes for ",string d];
 .sys.msg"Saved ",raze[.sys.comma'["i"$n%1e6],'("m trades, "; "m quotes -> "; "m nbbo (gzip ")],string["i"$avg .sys.zpct'[m]],"%)"}

savebid:{[t;q]
 i:bin/[{select sym,time from x`}'[(q;t)]];               /find indices of quote on/before trade
 {[t;q;i;c]gzip[` sv t,c]set q[c]i}[t;q;i]'[`bid`ask];    /add bid,ask column to trade table
 @[t;`.d;union[`sym`time`price`bid`ask]]}                 /add column names

savesym:{[d;w;m;s]                                                        /d:date, w:working dir, m:daily,trade,quote dirs, s:summary
 if[count k:duplicate s`sym; '"Duplicate symbol: ",", "sv string k];      /check if symbol repeated in original sub-partitions
 s:@[s;`trades`quotes`best;0^"j"$];                                       /prior to v3.0, counts are 4-byte ints
 s:update`u#sym from renum[w]update syms:string sym from s;               /save sym string, re-enumerate day's symbols
 m[`daily]set delete zi,ti,qi from s;                                     /save daily summary table
 saveattr[s;m]'[`trade`quote]; savebid . m`trade`quote; savecheck[d;m;s]} /write part'd sym col for trades & quotes, get bid/ask for trade

savedir:{[p;w;d]m!(` sv w,(`$string d),)'[(` sv p,)'[m:`daily`trade`quote],'`]}

saveday:{[a;b;e;r;p;w;d];  /a:target, b:block size, e:static enum flag, r:range table, p:prefix, w:working dir, d:date
 .sys.msg"Loading TAQ date: ",string d; daycheck d; zi:til count z:dirs d; m:savedir[p;w;d];
 r:dayrange(r;d); savesym[d;w;m]raze savepart[b;r;m]'[z;zi];               /save each sub-partition, re-enumerate from summary
 $[e; .sys.checksym[p;w;a]; .sys.savesym[p;w;a]]; .sys.movepart[w;a]d}     /if static enumeration, make sure no new syms, else update

savetable:{[a;p;c;b]  /a:db dir, p:prefix, c:config, b:flag set true if updating database
 k:`day`etf; v:(day c;etf c);  /if updating database, also save TAQ master from source, holidays from 2012 up to last source date
 if[b; k,:`master`holiday; v,:(`. `mas; {d+:til 0|1+last[x]-d:first x@:where x>2011.12.25; d[where 1<d mod 7]except x}sourcedate)];
 k!(` sv a,p,)'[k]set'v}

saverange:{[b;c;e;w;p;a;d]  /b:block size, c:config dir, e:static enumeration, w:working dir, p:prefix, a:target db, d:date(s)
 .sys.copysym[p;a]w:.sys.tempdir w; saveday[a;b;e;day c;p;w]'[d]; .sys.rmdir w; .sys.memory"job end";
 if[not e; savetable[a;p;c;1b]]}  /unless static enumeration, save in-memory tables

/ ----------------------------------------------------------------------------------------------------------------------------------
/       jobs: dictionary of job names and brief help message
/    default: returns dictionary of default arguments given job name
/       help: print help message to stderr given job name
/        arg: given job name, returns dictionary of job parameters, if job enlisted, defaults overridden with any command-line args
/      range: takes job args and returns list of dates to update, either n days back or dates within start,end
/    daysize: given date, returns size of uncompressed and compressed files in daily,trade & quote tables
/    summary: summary table indicating no. of trades, quotes, best bid/ask, size and gzip size over range of recent dates
/     report: given database path and string of email(s), creates summary report and emails or prints to stderr if no addresses
/      setup: given parallel flag and args, checks args and source TAQ data, signals error if invalid args, else returns dates
/     loader: overall controlling function for TAQ loader
/      hosts: checks hosts, calls loader on each host via ssh
/   parallel: initialize enumeration vector and call loader across multiple hosts, updating different dates across hosts
/ saveconfig: save updated configuration file(s) -> database table(s), currently only saves config/day.txt -> taq/taq/day
/ ----------------------------------------------------------------------------------------------------------------------------------
jobs:()!()
jobs[`load]:    "Update TAQ database with daily summary, trade flags, best bid/ask and compressed tables"
jobs[`parallel]:"Update TAQ database enumeration vector for a date range, then run parallel update tasks across hosts, segmenting dates"
jobs[`route]:   "Routing file"
jobs[`config]:  "Save configuration file changes -> TAQ database"

default:{if[not x in key jobs;'"Unrecognized job"]; .sys.default .sys.argfile[`taq]$[x=`parallel;`load;x]}
help:{.sys.usage[default x;jobs x;()]}
arg:{d:default j:first x; $[0<type x; .sys.arg[d;jobs j;()]; exec name!default from d]}

range:{[d;x] $[0<n:x`days; neg[n]#$[x`today;d;d except .z.D]; d where d within x`start`end]}

daysize:{
 t:raze .sys.zinfo each(` sv hsym[`$string x],)'[` sv'prefix,'`daily`trade`quote];
 `date xcols update date:x from $[count t; exec size:sum uncompressedLength,gzip:sum compressedLength from t;`size`gzip!0N 0Nj]}

summary:{[d]
 t:update pct:"i"$100*best%quotes from ?[`taq.daily;enlist(in;`date;d);{x!x}1#`date;{x!sum,'x}`trades`quotes`best];
 z:1!update size:.1*"i"$size%1e8,gzip:.1*"i"$gzip%1e8,zippct:"i"$100*1-gzip%size from daysize'[d];
 t:@[;`pct`size`gzip`zippct;string]@[;`trades`quotes`best;.sys.comma]([]date:d)lj/(t;z);
 t:update .sys.weekday date from`$1!@[t;`pct`zippct`size`gzip;{x,'?[x like"";"-";y]};"%%gg"];
 flip(`date,s,`trades`quotes,s,`best`pct,s,`size`gzip`zippct)#@[flip 0!t;s;:;s:`$"|"]}

report:{[a;e]  /a:db path, e:email(s)
 if[not`taq.daily in .sys.pt[];.sys.qload a]; d:{x where 1<x mod 7}.z.D-reverse 1+til 7;
 m:("Recent TAQ trade & quote counts, daily sizes:";""),.Q.S[20 120;0j]summary d;
 $[count e; .sys.mail[e;();();"Trade analysis";"Daily TAQ update";m;()]; -2 m];}

setup:{[p;x]                                                                                /p:true if parallel call, x:job args
 source x`source; d:range[sourcedate]x;                                                     /set range of dates to update
 if[not x`replace; d:d except .sys.part x`target];                                          /unless replacing, omit dates already loaded
 if[11h<>type key w:x`temp; '"working directory does not exist: ",1_string w];              /working directory must exist
 if[not[x`static]&n:count h:x`hosts; '"static enumeration required w'multiple hosts"];      /need -static 1 with multiple hosts
 if[p&not n; '"no hosts specified for parallel run"];                                       /need host list for parallel call
 if[n; h:exec host from {@[.sys.ypmatch;x;{[h;x]'"Unrecognized host: ",string h}x]}'[h];    /convert any alias to host name
  if[count e:duplicate h; '"host list not unique, duplicate: ",", "sv string e];            /must be unique after converting any alias
  if[not p; if[n=i:h?.z.h; '"host mismatch: ",string .z.h]; d@:where i=til[count d]mod n]]; /segment dates by host position in list
 d}                                                                                         /return dates

loader:{
 x:@[x;`target;.sys.dbtarget[dbname]x`local];                                                 /set default target if not specified
 .sys.banner"TAQ loader, host ",string[.z.h],", target ",(1_string x`target);                 /banner to mark start of job
 if[x`wait; if[.z.T>x`until; :.sys.msg"Wait mode set, but already past expire time of ",string x`until];
            if[not .taq.wait . x`source`until`sleep; :.sys.msg"TAQ not updated for previous weekday, quitting loader"]];
 if[0=count d:setup[0b]x; .sys.msg"No date(s) to update"];
 if[0<count d;
  m:"Load from ","-"sv string distinct(first;last)@\:d; p:prefix; a:x`target;                 /set msg, db prefix & path, working directory
  $[x`static; [.sys.msg m,:"  [static enumeration]"; .sys.dbcheck[a]p]; .sys.dbupdate[a;p]m]; /if static enum, check db, else initialize 
  saverange[x`block;x`config;x`static;x`temp;p;a;d]; m:"Completed: ",m;                       /save daily TAQ history
  $[x`static; .sys.msg m; .sys.dbfinish[a;p]m]];                                              /unless static, set completed db status
 if[x`route; loadroute x];                                                                    /create files for auto-routing if flag set
 if[x`sync; x[`syncpath]:.sys.dbtarget[dbname;not x`local;x`syncpath]; .sys.dbsync[prefix]. x`target`syncpath];
 if[x`report; .[report;(a;x`mail);{.sys.msg"ERROR: unable to create summary report - ",x," error"}]]}

hosts:{[h;n]   /h:hosts, n:number of threads for each host
 ssh:{system" "sv(.sys.which`ssh;"-q";string y;"'",x,"'")};
 if[any e:@[{x y;0b}[ssh .sys.which`hostname];;1b]'[h]; '"Unable to contact host: ",", "sv string h where e];
 c:" "sv("$Q"; .sys.startpath[]; "-s"; string n),ssr[;" ";"\\ "]'[.z.x], enlist" 1>>${QLOG}/taq.log 2>&1 &";
 .sys.msg"Running jobs on hosts: ",sv[", ";string h],"\nCommand: ",c;
 ssh[c]'[h];}

parallel:{
 x:@[x;`target;.sys.dbtarget[dbname]x`local]; .sys.msg"Target database: ",1_string x`target;
 if[0=count d:setup[1b]x; :.sys.msg"No date(s) to update"];   
 m:"Parallel update with static enumeration from ","-"sv string distinct(first;last)@\:d;
 p:prefix; a:x`target; w:.sys.tempdir x`temp; .sys.dbupdate[a;p;m]; .sys.copysym[p;a;w];   /initialize db, copy enum vector to working dir
 .sys.msg .sys.comma[n:count w` sv p,`sym]," symbol(s) currently defined";                 /keep track of symbols enumerated so far
 {[w;m;d]if[m;.sys.msg"Enumerating TAQ symbols for ",string"m"$d]; renum[w]([]asc distinct raze over daycheck d)}[w]'[differ"m"$d;d];
 .sys.savesym[p;w;a]; .sys.rm w; savetable[a;p;x`config;1b];                               /save new symbol vector, in-memory tables
 .sys.msg .sys.comma[count[a . p,`sym]-n]," symbol(s) added"; hosts . x`hosts`threads}     /run update across hosts

saveconfig:{
 x:@[x;`target;.sys.dbtarget[dbname]x`local];  /set default target if not specified
 f:savetable[x`target;prefix;x`config;0b];
 .sys.msg"Saved TAQ ETF list to: ",1_string f`etf;
 .sys.msg"Saved TAQ early close/late open/outlier days to: ",1_string f`day;
 if[x`sync; x[`syncpath]:.sys.dbtarget[dbname;not x`local;x`syncpath]; .sys.dbsync[prefix]. x`target`syncpath]}
