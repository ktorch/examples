\d .sys
/ ------------------------------------------------------------------------------------------------------------------------------
/ utilities for handling command-line arguments:
/ ------------------------------------------------------------------------------------------------------------------------------
/   split: return the break points for partial sums of y <= x (used to wrap text)
/    wrap: wrap string into sub-strings less than given width
/  getarg: convert command-line strings to same type as defaults, override where defined (replacement for .Q.def)
/ defread: read tab-delimited text file of defaults: name default choices help  (default & choices are strings to be executed)
/ defsave: save list/table of defaults to text file (default & choices are saved as executable strings of the q values)
/ deflist: take list of 4-element lists (name;default;choices;help) or one long list and convert to table
/ default: create table of defaults given file handle or array(s) of (name;default;choices;help) as one list, or n x 4
/          default may be scalar, list, or list of strings. choices may be empty, or list of allowable values
/          e.g. (`date; .z.D;    ();   "start date")
/               (`exch; "nq"; "amnqz"; "exchange(s), one of a,m,n,q,z")
/               (`exch; `n;    `n`q;   "pick one exchange symbol, n or q")
/   usage: print parameter defaults and descriptions to stderr
/     arg: parse command-line args, override defaults, check for -help, invalid parms
/          usage & arg take 3 arguments: 1-table of defaults (built by fn default), 2-brief overview, 3-help file or strings
/          arg[defaults;();()]
/          arg[defaults;"Overview..";`:helpfile]
/          arg[defaults;"Overview.."; helpstring(s)]
/ ------------------------------------------------------------------------------------------------------------------------------
split:{-2_(1+a bin a|x+-1_0,a:sums y)\[0]}
wrap:{" "sv'split[x;1+count each w]_w:" "vs y}
getarg:{x,(key[y]#x){$[s;raze;t<0h;first;::]$[s:10h=t:type x;t;type first x]$y}'y}
defread:{flip update`$name,get'[default],get'[choices]from(`$first r)!flip 1_r:"\t"vs'read0 x}
defsave:{x 0:"\t"0:@[y;`default`choices;-3!']}
deflist:{`name`default`choices`help!/:$[all 4=count'[x];x;0N 4#x]}
default:{$[98h=t:type x; x; -11h=t; @[defread;x;{'"Unable to read file\n",x}]; @[deflist;x;{'"Unable to parse defaults\n",x}]]}

usage:{
 x:default x; w:{raze wrap[85]'[` vs x]}; str:{x,$[0>t:type y;$[null y;"(null)";-3!y];$[count y;$[t=10;y;-3!y];"(empty vector)"]]};
 t:raze(raze flip each select name,w'[help]from x;
        select name,help:str["default: "]'[default]from x;
        select name,help:str["allowed: "]'[choices]from x where not 0=count'[choices]);
 m:("NAME";string .z.f),$[count y,:();("";"OVERVIEW";y);()],("";"OPTIONS");
 m,:2_.Q.S[2#100|system"c";0j]update{?[x=prev x;`;`$"-",'string x]}name,`$help from`name xasc t;
 -2` sv m,$[count z;("";"DESCRIPTION"),$[-11h=t:type z;@[read0;z;()];10h=abs t;enlist z,();z];()];}

arg:{
 if[`help in lower k:key c:.Q.opt .z.x; usage[x;y;z]; exit 1];
 if[count u:k except key a:exec name!default from x:default x; '"Undefined parameter: ",","sv string u];
 a:@[getarg[a]c;exec name from x where{$[11h=type x:raze over x;any x like":*";0b]}'[default];hsym];
 $[null c:first where not all'[(key[s]#a)in's:exec name!choices from x where not 0=count each choices]; a; 'string[c]," not in ",-3!s c]}
\d .sys
country:@[{1!("SSSS";1#"\t")0:x};` sv config[`sys],`country.txt;{-2 "ERROR reading country file:\n",x;}]
\d .sys
/ ------------------------------------------------------------------------------------------------------------------
/  utilities to create,update and load databases (splayed/partitioned)
/ ------------------------------------------------------------------------------------------------------------------
/    dbstat: given status,message,error, create dictionary used for database status w'current time,user,host etc.
/  dbstatus: write status code, 0:ok, n-updating/error, message to "status" dictionary given directory
/   dbstart: set status:1 to indicate updating given directory and message
/    dbdone: set status:0 to indicate update completed given directory and message
/ ------------------------------------------------------------------------------------------------------------------
dbstat:{`status`time`message`user`host`pid`port!(x;.z.P;y;.z.u;.z.h;.z.i;system"p")}
dbstatus:{@[x;`status;:;dbstat[y;z]]}
dbstart:{dbstatus[x;1;y]}
dbdone: {dbstatus[x;0;y]}

/ ----------------------------------------------------------------------------------------------------------------------
/   dbinit: given database path & prefix, initialize/verify file structure, return path
/           dbinit[`:db/test;`bloom] -> db/test/bloom/sym      if not found, set to empty symbol vector w'unique attr set
/                                       db/test/bloom/status   if not found, set to dictionary of timestamp, msg, etc.
/  dbcheck: checks for status and sym vector, if found returns path, else signals error
/   dbsync: given prefix x, paths y,z, rsync y->z, set status for prefix x in z, e.g. z/x/status indicating progress
/ dbupdate: given database dir, prefix & message, display message, initialize dir, set status message indicating update
/ dbfinish: print message, set update complete status & message in given database directory & prefix
/ dbtarget: given name, local flag & path, if path is not set, return default database path (used by loader jobs)
/ ----------------------------------------------------------------------------------------------------------------------
dbinit:{
 if[not 2h=filetype p:first` vs x; '"Not an existing directory: ",1_string p];
 if[not`sym in k:key w:` sv x,y; @[{@[x;`sym;:;`u#0#`]};w;{'"Unable to initialize database symbols: ",x}]];
 if[not`status in k; .[dbstatus;(w;0;"Initialized database");{'"Unable to initialize database status: ",x}]];
 x}

dbcheck:{$[11 99h~type each @[{x . y}x;;{-2"ERROR: checking db ",x;}]'[y,'`sym`status]; x; '"Invalid db path: ",1_string x]}

dbsync:{                                              /x:prefix, y:source, z:target  
 w:{1_x,(x like"*[^/]")#"/"}'[string (y;z)];          /strings from directory handles, add trailing slash
 msg m:" -> "sv("Rsync ",w 0;w 1);                    /log message indicating rsync call
 dbstart[` sv z,x]m;                                  /write status msg to target indicating sync in progress
 r:(which`rsync;"-a";"--delete");                     /basic rsync call
 system" "sv r,("--exclude";s:string[x],"/status"),w; /exclude status file from initial syncronization
 system" "sv r,w,\:s;                                 /sync source/statusfile -> target/statusfile
 msg "Rsync completed"}

dbupdate:{msg z; dbinit[x;y]; dbstart[` sv x,y;z]; x}
dbfinish:{msg z; dbdone[` sv x,y;z]; x}
dbtarget:{$[any z~/:(`;`:;::); ` sv db[y],x; z]}

/ ------------------------------------------------------------------------------------------------------------------
/  utilities to copy sym from db to working dir, from working dir back to db, to enumerate while saving to work dir
/ ------------------------------------------------------------------------------------------------------------------
/  copysym: given prefix,db dir,working dir, copy from db to work, e.g. db/bloom1/bloom/sym -> db/tmp/bloom.sym
/  savesym: given prefix,working dir,db dir, save from work to db, e.g. db/tmp/bloom.sym -> db/bloom3/bloom/sym
/ checksym: check that `:db/prefix.sym matches `:work/prefix.sym and in-memory vector  (used w'static enumeration)
/      sym: enumerate table given dir,database prefix and table, e.g. dbsym[`:/db/tmp; `bloom; table]
/ ------------------------------------------------------------------------------------------------------------------
copysym: {[s;z;w]r:(` sv w,` sv s)set z .   s:s,`sym; r?`; r}
savesym: {[s;w;z]  (` sv z,s)     set w` sv s:s,`sym}
checksym:{[s;w;z]if[not all(w` sv s)~/:(z;`.).\:s:s,`sym;'"Enumeration vector mismatch between working dir and db"]}
sym:{.sys.enum[x;` sv y,`sym;z]}

/ -------------------------------------------------------------------------------------------------------------------------------------------------------
/ utilities to add new columns or change column order in existing partitioned table
/ -------------------------------------------------------------------------------------------------------------------------------------------------------
/ changepart: add new column(s) and/or change column order for individual partition dir
/ changecols: add new column(s) and/or change column order in partitioned database table
/ -------------------------------------------------------------------------------------------------------------------------------------------------------
changepart:{[w;c;k;t;d]                                                                 /w:db path, c:map of column->null value, t:table name, d:date
 w:` sv w,(`$string d),t;                                                               /w:dir for daily partition, e.g. `:db/2016.03.16/stock.trade
 z:$[n:count w`; 0<zpct` sv w,first k; 0b];                                             /n:record count, z:gzip flag
 if[a:count c;{[w;n;z;c;v] w:` sv w,c; $[z;gzip w;w]set n#v}[w;n;z]'[key c;get c]];     /save n null values for each column to be added
 m:$[a;sv[",";string key c]," added",$[z;" w'gzip";""]," to"; "column names updated"];  /m:message indicates if columns added or just an update to names
 .sys.msg(m;1_string @[w;`.d;:;k])}                                                     /print message for each date after addition/update

changecols:{[w;c;t]                                                                     /w:db path, c:map of column->datatype, t:table name
 if[0=count d:@[part; w; ()]; '"No dates for db path: ",1_string w];                    /d:dates in database, signal error if none found
 k:key c; c:where[not null c]#c;                                                        /k:all columns, existing & new, new has non-null datatypes
 a:w . (`$string last d),t,`.d;                                                         /get existing columns
 if[count o:a except k; .sys.msg"Warning: omitting column: ",","sv string o];           /cols removed from .d file, still exist in partition dirs
 s:(first` vs t;`sym);                                                                  /s:prefix+`sym, e.g. `stock`sym
 if[null s:@[{`$2_string sv[`;``,y]set x . y}w;s;`]; '"Unable to define db symbols"];   /define database enumeration vector
 c:@[;where c="*";"c"$]@[1#'c$\:(); where c="S"; s$];                                   /create dictionary of new column name(s) -> null value(s)
 changepart[w;c;k;t]'[d]}                                                               /add new columns for each date w'null data types
\d .sys
/ -----------------------------------------------------------------------------------------------------------------------------------
/     chmod: change file permissions, first arg is int(777), string("a+rx") or file handle to match, 2nd arg is handle
/        ls: error-trapped version of key -- prints error, returns empty array on unreadable dirs
/      tree: recurse through members of given tree symbol/file/dir handle
/  filetype: given file handle, return 0h-doesn't exist, 1h-file, 2h-dir
/  filetree: return list of file/dir handles given file/dir handle, else empty
/  filelist: return dictionary of files/dirs -> type in given directory(one level only,assume dir if error getting key)
/     files: return list of file handles given directory
/      dirs: return list of directories given directory
/        rm: remove each file & dir in tree via error-protected hdel call (slower than /bin/rm), return deleted list
/     rmdir: remove dir(s) via system call: /bin/rm -rf, return list of dir(s) not removed, displays any errors
/     mount: given file handle(s), returns mount point(s) as dir handles
/ sambapath: attempts to resolve linux directory handle to samba path accessible from windows, `:/data/cost -> \\samba\costprod\data
/ -----------------------------------------------------------------------------------------------------------------------------------
chmod:{a:$[10h=t:type x; x; t in -5 -6 -7h; string x; t=-11h; "--reference=",1_string hsym x; '`type]; system" "sv(which`chmod;a;1_string hsym y)}
ls:@[key;;{-2 x;()}]
tree:{$[x~k:ls x;x;x,raze (.z.s` sv x,)'[k]]}
filetype:{$[null x; 0h; x~hsym x; "h"$0 -11 11h?type ls x; '`type]}
filetree:{$[filetype x;tree x;()]} 
filelist:{((0#`)!0#0h),$[2h=filetype x;(!/)flip{y,@[{$[x~ls x;1h;2h]};y:` sv x,y;2h]}[x]'[ls x];()]}
files:{where 1h=filelist x}
dirs:{where 2h=filelist x}
rm:{raze{@[hdel;x;{-2"Unable to delete ",x;()}]}each reverse filetree x}
rmdir:{"s"$@[system; " "sv(which`rm;"-rf"),s; {-2 z,": unable to remove ",", "sv y i:where not()~/:key'[x]; x i}[x]s:(1_string@)each x,:()]}
mount:{$[0>type x;first;::](hsym`$last@)each" "vs'1_system" "sv(which`df;"-P"),(1_string@)'[x,()]}

sambapath:{
 if[not 11h=type key x;'"Not a directory: ",1_string x]; s:string m:mount x; x:string x;
 p:$[x like ":/home/*"; ssr[x;s;string last` vs m]; m~mount data[]; ssr[x;s;"costprod/data"]; '"Unable to determine Samba path"];
 ssr["//samba/",p,$[p like"*/";"";"/"];"/";"\\"]}

/ ------------------------------------------------------------------------------------------------------------------
/ tempmask: mask for temp files, flag indicates if mask is for creation(true) or matching(false)
/   mktemp: call system utility to make temporary file or directory
/  tempdir: mktemp with bit flag true for directory, arg is dir whter temp subdir is created
/ tempfile: mktemp with bit flag false for temporary file, arg is dir where temp file created
/ ------------------------------------------------------------------------------------------------------------------
tempmask:{"qtemp.",10#$[x;"X";"?"]}
mktemp:{hsym`$first system" "sv("TMPDIR=",s;.sys.which`mktemp;$[y;"-d";""];"-p";s:1_string`:/tmp^x;tempmask 1b)}
tempdir: mktemp[;1b]
tempfile:mktemp[;0b]

/ -------------------------------------------------------------------------------------------------
/  gzip: given file, creates arguments for default gzip level and blocksize
/ zinfo: return table of file and information returned by -21! recursing through directory level(s)
/  zpct: return compression percentage
/ -------------------------------------------------------------------------------------------------
gzip:(;17;2;6)

zinfo:{
 f:{$[count r:-21!x;r;`compressedLength`uncompressedLength`algorithm`logicalBlockSize`zipLevel!(hcount x;0i)where 2 3]};
 $[x~k:key x;first;::]{[f;x]$[x~k:key x; flip((1#`file)!1 1#x),f x; raze(.z.s[f]` sv x,)'[k]]}[f]x}

zpct:{100*1-exec sum[compressedLength]%sum uncompressedLength from zinfo x}

/ ------------------------------------------------------------------------------------------------------------------
/   rename: q's internal rename x->y, if x is file, y can be existing file, if x is dir, y can only be empty dir
/ movetemp: if x exists, create temp dir in x's parent directory and move x into it
/     move: move x->y, return y  y must not already exist. return null if no x, treat null y as move to temp dir
/ movework: if working dir on different file system, move working partition to target file system in a temp dir
/ movepart: move partition z from working dir x -> y  leave any subdirs in y/z if not also in x/z
/ ------------------------------------------------------------------------------------------------------------------
rename:{system"r "," "sv(1_string hsym@)'[(x;y)]; y}
movetemp:{$[t:filetype x; rename[x;mktemp[first` vs x;t=2h]]; `]}
move:{$[filetype x; $[null y; movetemp x; t:filetype y; '" "sv(("";"File";"Directory")t;"exists:";1_string y); rename[x]y]; `]}
movework:{system" "sv enlist[which`mv],(1_string@)'[(` sv x,`$string z; w:tempdir first` vs y)]; w}

movepart:{                                                     /x-working dir, y-target, z-partition value
 if[m:not=/[mount x,y]; x:movework[x;y;z]];                    /move work dir -> temp dir on target file system
 t:type each k:key each d:{first` vs .Q.par[y;x;`]}[z]'[x,y];  /check partition in source & target
 if[not 11h=first t;'"Not a directory: ",1_string d 0];        /source partition must exist
 if[-11h=t@:1; hdel d 1; t:0h];                                /if target partition is file, erase
 if[0h=t; rename . d; if[m;rmdir x]; :last d];                 /if no target, simple rename
 {rename .` sv'x,'y}[d[1],w:tempdir x]'[inter/[k]];            /move target subdirs -> temp if in source
 {rename .` sv'x,'y}[d]'[k 0]; rmdir w,$[m;x;first d]; last d} /move source subdirs -> target, cleanup, return target partn

/ ------------------------------------------------------------------------------------------------------------------
/     par: given dir handle, return dirs in par.txt file if exists, else return dir itself
/   parts: given dir handle, return dictionary of dir(s) mapped to date/month/year/int partitions
/    part: union of all date/month/year/int partitions found in given dir (uses par.txt if found)
/ mapdate: utility to map daily partition, either from loaded database or from context defined dates & database path
/ ------------------------------------------------------------------------------------------------------------------
par:{$[p~key p:` sv x,`par.txt; hsym'[`$read0 p];x]}
parts:{p!{k where not null k:$[count k;"DMJJ"10 7 4?count first k;"*"]$k:string{x where x like"[0-9]*"}key x}'[p:(),par x]}
part:{union/[parts x]}

mapdate:{[c;t;d]   /c:context, e.g. `.taq or `.cmf, t:table name, d:date
 v:$[t in .sys.pt[]; (.Q.pv;`:.); any(::)~/:v:c`date`path; 'string[t]," path & dates not defined"; v];
 s:`$string $[b:d in v 0;d;last v 0]; $[b;::;0#]v[1] . s,t,`}
\d .sys
/ ----------------------------------------------------------------------------------------------------------------------------------------------
/ system functions to start up a grid of processes across host(s), used with q process initiated with -s -n command-line argument
/ ----------------------------------------------------------------------------------------------------------------------------------------------
/       guid: unique id for session (used to uniquely distinguish grid tasks, allow listeners to authorize connections using host:port:user:id)
/       grid: table of host, pid, handle, listener flag, port (empty, unless this session establishes a set of grid tasks and listeners)
/  gridcount: return number of distributed processes specified via -s -n, else 0, (-s -1 returns zero, no grid with only one process)
/ gridhandle: given host & port of listener task, return handle for a grid task to open a connection (e.g. to enumerate/save a table)
/ gridswitch: 0:turn off distributed peach, 1:.z.pd returns defined grid tasks for peach, 2:grid tasks+listeners
/  gridready: given number of grid & listener tasks, if all connected, displays table & returns true, else returns false
/    gridrun: given exit flag, function and args, runs function under error trap and exits on completion/error if exit flag true
/    gridssh: return system command string to echo hopen call into a q session run via background ssh task
/   gridtask: start n q tasks across host(s) via ssh with hopen call to parent piped into stdin, stdout,stderr of remote q back to parent
/   gridopen: function to use for connection callback while grid is started, will run given function once grid tasks are connected
/  gridstart: used to initiate the grid, uses .z.po callback to collect grid tasks and run specified function
/ ----------------------------------------------------------------------------------------------------------------------------------------------
guid:@[get;`guid;rand 0Ng]                                                    /initialise session id
grid,:2!flip`host`pid`handle`listen`port!"SIIBI"$\:();                        /initialize table of grid processes if not already defined
gridcount:{$[-1>g:system"s";neg g;0i]}                                        /return distributed processes specified if 2 or more, else 0
gridhandle:{[h;p]`$":"sv string(`;h;p;.z.u;guid)}                             /given host & port of listener, return handle required for access
gridswitch:{$[x=1; .z.pd:{`u#exec handle from grid where not listen}; x=2; .z.pd:{`u#exec handle from grid}; system"x .z.pd"];}

gridready:{[g;l]$[all(g;l)=0^(exec count i by listen from grid)01b; [-2'[("";.Q.S[80 80;0;grid];"")]; 1b]; 0b]} /g:grid tasks, l:listeners
gridrun:{[e;f;x]$[e;exit;::]@[{x y;0}f; x; {-2"Error running grid function: ",x;1}]}                            /e:exit flag, f:function, x:args
gridfile:{hclose neg neg[hopen f:.sys.tempfile x]":"sv(string .z.u;raze string md5 string guid); f}             /user:pass file for controlling access

gridssh:{[l;s;u;h]                                                       /l:listener flag, s:threads, u:user access file, h:remote host/alias/address
 c:"echo 'hopen`$\"",sv[":";string(`;.z.h;system"p";.z.u;guid)],"\";'";  /echo 'hopen`$"host:port:guid";'
 c,:" | ",which[`ssh]," -q ",string[h]," $Q -s ",string s;               /pipe hopen command to q task run via background ssh task
 if[l; c,:" -p 0W -U ",1_string u]; c," &"}                              /if listener, get next available port, run with -u tmpfile

gridtask:{[n;l;s;u;h]system'[gridssh[l;s;u]'[.z.h^n#h]];}                /n:number of grid tasks, l:listener flag, u:user file, s:threads, h:host(s)

gridopen:{[e;f;x;g;l;u;z;w] /e:exit flag, f:function to run, x:args, g:grid tasks, l:listeners, u:user file, z:prev state, w:opened handle
 grid[2#s]:w,(0<>p),p:last s:w({.z.pc:{if[x=y;exit 0]}.z.w; (.z.h;.z.i;system"p")};0);      /set grid task to exit on parent close, return host,pid,port
 if[gridready[g;l]; if[not null u;@[hdel;u;()]]; if[0=z 0;system"p 0"];                     /if grid tasks & listeners ready, delete temp file, reset port
  `.z.pw`.z.po{$[null y;system"x ",string x;x set y]}'z 1 2; gridswitch 1; gridrun[e;f;x]]} /restore previously defined callbacks, activate grid & run fn

gridstart:{[e;f;x;g;h;s;l]  /e:exit flag, f:function to run, x:args to function, g:grid tasks, h:hosts, s:threads per grid task, l:local listener(s)
 h:(1|count h)#h,.z.h;                                                                     /use local host if empty list of hosts
 msg("Grid of"; l; "local ",neg[l=1]_"listeners"; "+"; g; "tasks on"; ","sv string h);     /indicate grid startup
 if[gridready[g;l]; gridswitch 1; gridrun[e;f;x]; :(::)];                                  /exit early if grid already established
 u:$[l;gridfile`:/tmp;`]; z:system["p"],@[get;;{}]'[`.z.pw`.z.po];                         /user access file, previous port,validate & open callbacks
 .z.pw:{[x;u;p](u;p)~(x;string guid)}.z.u; .z.po:gridopen[e;f;x;g;l;u;z];                  /[re]define validate & open callbacks
 if[0=z 0; system"p 0W"]; gridtask'[g,l;01b;s,0;u;(h;.z.h)];}                              /set port if none, use ssh to start tasks & listeners
 
/ ----------------------------------------------------------------------------------------------------------------------------------------------
/ gridarg: given dictionary of job args, supplies default host list, threads per grid task, count of listeners if not specified in arguments
/ jobgrid: given exit flag, function, args & count of grid tasks, initiates grid and runs function
/ jobtest: initiate grid according to job arguments without running any function
/ jobtrap: run specified function with given args under error trap, exit with 0-success, 1-error
/     job: run job via grid if -s -n specified, else under error trap with exit on completion or error
/ ----------------------------------------------------------------------------------------------------------------------------------------------
gridarg:{(a,x)key a:`hosts`threads`listen!(1#.z.h;0;0)}                                             /host list, threads per task, number of listeners
jobgrid:{[e;f;x;g]gridstart[e;f;x;g]. gridarg x; :(::)}                                             /e:exit flag, f:function, x:args, g:no. of grid tasks
jobtest:{if[not g:gridcount[];'"Distributed mode not set with -s -n"]; jobgrid[0b;{};x;g]}          /initiate job grid without running any function
jobtrap:{[f;x] exit @[{x y;0}f; x; {-2"ERROR: running ",string[$[-11h=type x;x;`job]],", ",y;1}f]}  /run f x under error trap, exit
job:{[f;x]$[x`debug; [`..x set x;]; g:gridcount[]; jobgrid[1b;f;x;g]; jobtrap[f;x]]}                /f:function name or function, x:dictionary of args
\d .sys
/ ------------------------------------------------------------------------------------------------------------------
/ attach: return 2 strings: newer form of "-a file.." and older: "uuencode a; uuencode .."
/         attach takes name of working directory and attachment(s)
/         attachments can be one or more triplets of (name;type;data), e.g. (`data.csv;"c"; ("sym,prc";"ibm;100.0"))
/         or (names;types;arrays), e.g. (`data.csv`data; "cx"; (("sym,prc";"ibm;100.0"); 1 2 3.5))
/   mail: send mail given a:address, c:cc, b:bcc, f:from string, s:subject string, m:message body, x:attachment(s)
/         address for to,cc,bcc can be symbol(s) or string (string can separate emails by comma, no spaces)
/         "from" string for senders name/description -- from & subject strings substitute backtick for any "'"
/ ------------------------------------------------------------------------------------------------------------------
attach:{[w;x]
 f:{[w;n;t;x]1_string(0:;1:;set)["cx"?t][` sv w,n;x]}[w]./:x:$[-11h=type first x;0N 3#x;flip x];
 (" "sv"-a ",/:f; raze" ; ",/:f{" "sv(x;y;string first z)}[which`uuencode]'x)}

mail:{[a;c;b;f;s;m;x]  /a:address, c:cc, b:bcc, f:from string, s:subject string, m:message body, x:attachment(s) (name;type;val);.. or (names;type;vals)
 qt:{"'",ssr[x,();"'";"`"],"'"};                                                          /fn to enclose string in single quotes (backtick for embedded)
 to:{$[count y; $[count x;x," ";""],$[10h=type y,:();y;","sv string y]; ""]};             /handle address(es) as single string, or symbol(s)
 try:@[{system "(",x," 2>/dev/null)";1b}; ; 0b];                                          /attempt system cmd, 1b if succeed, 0b failure
 z:" "sv(which`cat; 1_string tempfile[w:tempdir`]0:$[10h=abs type m;enlist m,();m,\:()]); /"cat tempfile"
 z:{(x," | ",y," ",z 0; "(",x,z[1],") | ",y)}[z;which`mail;attach[w]x];                   /2 forms: "cat f | mail -a .."  "(cat f; uuencode ..) | mail"
 z:z,\:" "sv(to["-c"]c; to["-b"]b; "-s"; $[count s;qt s;"(no subject)"]);                 /add: "-c cc -b bcc -s subj"
 z[0],:$[all count'[(f;u:getenv`USER)];" -r ",qt u," (",f,")";""],to[" ";a];              /newer: " -r 'user (description)' to"
 z[1],:to[" ";a],$[count f;" -- -F ",qt f;""];                                            /older passthru to sendmail: " to -- -F 'from name'"
 if[not try z 0; if[not try z 1; -2"ERROR: unable to send mail"]];                        /try newer mail call, then older form if failure
 @[system;" "sv(which`rm;"-rf";1_string w);{-2"Unable to erase temporary dir used for email:\n";x}];}
\d .sys
/ ----------------------------------------------------------------------------------------------------------------
/ utilities for system paths, resources, etc
/ ----------------------------------------------------------------------------------------------------------------
/   version: numeric version number
/      path: given subdir(s), return full path from $QCOST location, e.g. path`taq
/      data: given subdir(s), return full path from $QCOSTDATA location, e.g. data`logs
/     local: given subdir(s), return full path from $QCOSTLOCAL location, e.g. local`q`cost
/        db: given flag: 1b for local, 0b for NFS, returns database location
/    dbpath: given local flag & prefix, tests for local, if exists returns local db path, else nfs, else null
/    config: builds config path from given subdirectory, ${QCOST}/(subdir)/config
/   context: given symbol(s) returns context, e.g. `bloom -> `.bloom
/    source: builds dictionary of source names and associated paths/connection parameters
/   argfile: given subdir and name of job, returns file with default arguments and descriptions
/  nullpath: return true if null symbol, null handle, empty list or functional null given
/      host: returns table of MTAS hosts, with flags indicating those with raid arrays and designated "main" host
/     alias: attempts to find alias of the form: mtas(n), else first alias, else null
/     which: dictionary of system binary name to full path (string)
/ startpath: convert any relative starting path or script to full path, returns full path as string
/ ----------------------------------------------------------------------------------------------------------------
version:1.4
path:{` sv hsym[`$getenv`QCOST],$[x~(::);();x]}
data:{` sv hsym[`$getenv`QCOSTDATA],$[x~(::);();x]}
local:{` sv hsym[`$getenv`QCOSTLOCAL],$[x~(::);();x]}
db:{$[x;local;data]`db}
dbpath:{$[y in key w:db x; ` sv w,y; x; .z.s[0b]y; `]}
config:{path x,`config}
context:{(` sv`,)'[x]}
source:@[get;;{-2"ERROR: reading system source file"; ::}]each!/["S*"$flip 1_2#'"\t"vs'read0` sv config[`sys],`source.txt]
argfile:{path x,`default,` sv y,`txt}
nullpath:{any x~/:(`;`:;::;())}

host:{
 if[count e:where 0=count each h:{x!{`$" "vs getenv x}'[x]}`MTASMAIN`MTASRAID`MTASHOST; '"Undefined MTAS host setting: ",","sv string e];
 update main:any(host;alias)in h`MTASMAIN,raid:alias in h`MTASRAID from update {x first where x like"mtas*"}'[alias]from ypmatch'[h`MTASHOST]}

alias:{if[null first x;x:.z.h]; @[{a{last iasc x like"mtas?"}a:.sys.ypmatch[x]`alias};x;{-2"ERROR: unable to get mtas alias (",x,")";`}]}

which:raze{y!1_'string(` sv x,)each y,:()}./:raze flip each
 ((`:/bin;     `cat`chmod`cp`df`grep`gunzip`gzip`hostname`ln`mail`mkdir`mktemp`mv`readlink`rm`sleep);
  (`:/usr/bin; `find`head`id`mysql`nohup`rsync`ssh`stat`test`uuencode`wget`ypmatch`zgrep`zip);
  (`:/usr/sbin; 1#`zdump))

startpath:{$[null f:.z.f; ""; first system" "sv(which`readlink;"-f";string f)]}

/ -------------------------------------------------------------------------------------------------------------
/  utilities for loading database paths or .q scripts
/ -------------------------------------------------------------------------------------------------------------
/ qload1: given list of subdirectories in database, loads in-memory objects or splayed tables as deferred maps
/ qload2: substitute for q's .Q.l to allow for deferred maps below the database directory level
/  qload: call \l on .q/.k scripts, else call database loader: qload1 & qload2
/ reload: reload the all the defined variables & functions in the QCOST environment
/ -------------------------------------------------------------------------------------------------------------
qload1:{
 if[last[x]like".nfs*"; :()];                  /skip nfs locking files
 s:`.d=first k:key h:` sv `:.,x;               /check if path indicated by x is a splayed table
 if[s|h~k; :set[` sv``,x]$[s;h`;get h]];       /if x splayed dir or file, define at depth of x
 if[0>type x; ![`.;();0b;1#x]]; .z.s'[x,/:k]}  /if at top level, erase x in root, define dictionary of subdirs & files

qload2:{
 if[$[1>type d:key f:hsym x; 1; `.d~first d]; :.[$[.Q.qt d;last` vs f;`.];();:;d:get f]];  /if single file or splayed dir
 d@:where not d like"*$";                                                                  /files/dirs without "$" suffix
 p:(d=`par.txt)|d like"[0-9]*";                                                            /true for par.txt or date/mo/yr/n partn
 system"cd ",string x;                                                                     /move to given dir
 qload1'[d where not(d=`html)|p|s:"."in'string d];                                         /load files,splays & subdirs of files,splays
 if[any p;.Q.L d where p];                                                                 /load partitions
 if[not`.=x; (system"l ",string@)'[d where s&not p]];}                                     /load any .q/.k scripts

qload:{x:(":"=first s)_s:$[10h=abs type x;x;string x]; $[x like"*.[kq]"; system"l ",x; qload2`$x]}

reload:{qload path`sys`q.q}
{$[count e:getenv`QCOST; {@[system;"l ",x;{-2"Error: loading ",x,"\n",y}x]}'[e,/:x]; -2"Environment variable: QCOST not defined"];}
 ("/sys/path.q";            /utils for deriving paths relative to env variables QCOST,QCOSTDATA, linux binaries
  "/sys/config.q";          /read in config files -> tables,maps
  "/sys/file.q";            /file system utilities
  "/sys/db.q";              /database functions to initialize,update and sync databases
  "/sys/time.q";            /timezone functions to map between local & gmt time
  "/sys/util.q";            /basic system utilities
  "/sys/mail.q";            /mail utilities
  "/sys/arg.q";             /functions to process command line arguments
  "/sys/grid.q";            /functions for using a grid of processes with distributed each
  "/xl/xl.q";               /utilities for building basic XML-based spreadsheets
  "/taq/taq.q";             /TAQ functions to access trades & quotes w'out direct load
  "/bloom/bloom.q";         /Bloomberg functions
  "/oms/oms.q";             /functions for retrieving OMS detail records and saving to daily partitioned database
  "/oms/oms.trade.q";       /functions for summarizing OMS detail records into stock trades
  "/oms2/oms.q";            /functions for OMS database updated using file extracts
  "/cmf/cmf.q";             /functions for parsing CMF records from log files
  "/cmf/cmf.trade.q";       /functions for condensing CMF messages into "registered" orders
  "/broker/broker.q";       /functions for broker reports, executing broker vs prime broker tickets & shares, etc
  "/mlpx/mlpx.q";           /functions for MLPX crossing report
  "/sor/sor.q";             /functions for SOR performance database
  "/test/test.q";           /functions for PM trade file performance analysis
  "/datascope/datascope.q"; /functions for processing Reuters Datascope Equities -- daily prices and reference data
  "/tic/tic.q";             /functions for processing Reuters tick history
  "/tic/ticmap.q";          /functions for mapping condition codes -> flags, e.g. include,open,close, etc.
  "/tic/ticroute.q";        /functions for creating non-US autorouting thresholds
  "/stock/stock.match.q";   /functions to match trade symbols to US TAQ tick data, Reuters
  "/stock/stock.time.q";    /functions to determine trade start & end time from send/acknowledgement, first/last fill, stop/cancel/replace time
  "/stock/stock.calc.q";    /functions to calculate cost measures: prevailing quote, interval vwap, etc
  "/stock/stock.formula.q"; /maps & functions to calculate cost formulas: market & sector return, cost estimates
  "/stock/stock.load.q");   /functions used by daily loader
\d .sys
/ ----------------------------------------------------------------------------------------------------------
/ utilities for calculating gmt/local times
/ ----------------------------------------------------------------------------------------------------------
/        zone: read set of system time zones from configuration file
/      offset: read gmt offsets for all time zones and switch points around daylight savings time
/   gmtoffset: dictionary by zone and switch times, mapping timestamp -> gmt offset in seconds
/ localoffset: dictionary by zone and switch times, mapping timestamp -> local offset in seconds
/   localtime: given time zone and timestamp, convert GMT time -> local time
/     gmttime: given time zone and timestamp, convert local time -> GMT time
/     maptime: given zone1, zone2 and timestamp, convert from time in zone1 -> time in zone2
/       zdump: retrieve gmt offsets for all system timezones, return table with dates 2009 -> current year+5
/   zdumpsave: save zdump table as tab-delimited text, reformat gmt & local timestamp to make more readable
/ ----------------------------------------------------------------------------------------------------------
zone:("SS";1#"\t")0:` sv config[`sys],`zone.txt
zonealias:exec alias!zone from("SS";1#"\t")0:` sv config[`sys],`zonealias.txt
offset:([]zone:`GMT`UTC;gmt:0Np;local:0Np;dst:0b;offset:00:00:00)
offset,:@[{("SPPBV";1#"\t")0:x};` sv config[`sys],`offset.txt;{-2"Unable to read timzone offsets: ",x;`zone`gmt`local`dst`offset!"SPPBV"$\:()}]
gmtoffset:  exec `s#  gmt!offset     by zone from offset
localoffset:exec `s#local!neg offset by zone from offset

localtime:{y+x gmtoffset'y}
gmttime:{y+x localoffset'y}
maptime:{localtime[y]gmttime[x]z}

zdump:{
 r:system" "sv(which`zdump;"-v";"-c";string 5+`year$.z.D),string zone.zone;
 r@:where r like "* gmtoff=*";
 r:{x where 16=count'[x]}{{x where not x like""}" "vs x}'[r];
 r:(r[;0]; " "sv'r[;3 2 5 4]; " "sv'r[;10 9 12 11]; (last"="vs)each r[;14]; (last"="vs)each r[;15]);
 t: update"v"$offset from flip`zone`gmt`local`dst`offset!"SPPBI"$r;
 t:delete from t where any flip null t;
 t@:where differ select zone,offset from t;
 delete from t where gmt<(last;gmt)fby zone,gmt.year<2009}

zdumpsave:{$[any x~/:(`;`:;::); ` sv config[`sys],`offset.txt; x]0:"\t"0: @[zdump[];`gmt`local;{" "sv string"dv"$x}']}
\d .sys
/ ---------------------------------------------------------------------------------------------------------------------
/ general system utilities
/ ---------------------------------------------------------------------------------------------------------------------
/       msg: timestamped message given string, strings or syms/numbers/dates
/    banner: surround timestamped message with lines (designed to mark beginning of log output for jobs)
/       ymd: return date(s) as yyyymmdd integer(s)
/        pt: return names of partitioned tables (get .Q.pt if exists, else empty list)
/      enum: enumerate symbol columns given target directory, sym vector name & table
/     denum: denumerate scalar,list or table symbol columns
/       day: return 3-letter day of week given date
/   dayname: return full day of week given date
/   weekday: return day of week and mm/dd part of date, e.g. weekday 2012.08.22 -> `Wed 08/22
/    across: display n columns of output, e.g. across[5;cols t]  or across[5;dictionary/table]
/     comma: format numeric as string, "67,123"
/    digits: set digits of print precision, returns previous setting
/     sleep: sleep given number of seconds or derive seconds from time/minute/second argument 
/       col: rename columns in x to y in table z
/  moveleft: move columns x together and to left from table y
/ moveright: move columns y together and to right from table y
/ datebound: return lower,upper bounds of date range given year(s),month(s),date(s)
/ pricedate: given access function, key column & reference date, return map of key -> latest price date in past week
/   nullinf: use null in place of infinity in given scalar/list
/  partfail: find elements out-of-sequence: e.g. `z`z`b`c`a`a`b`b`c -> `b`c (cannot apply `p attribute)
/   ypmatch: given host,alias or ip address as symbol, return dictionary of addr,host,alias(es)
/   soundex: convert symbol(s)/string(s) to code, attempts to match similar sounds to same code
/  logfiles: return table of host,job,log file given log dir, null or empty arg uses system default for log directory
/    memory: saves memory use along with  timestamp and optional note(string,sym,number) to global table: Memory
/ ---------------------------------------------------------------------------------------------------------------------
msg:{t:"dv"$\:.z.P; v:t,$[10h~type x,:();enlist x;x]; -2" "sv@[v;where not 10h=type'[v];string];}
banner:{u:100#"_";-2(u;""); msg x; -2 u;}
ymd:{100 sv`year`mm`dd$\:x}
pt:{$[`pt in key`.Q;.Q.pt;0#`]}
enum:{[d;s;x]if[count c:where 11h=type each flip x;(` sv d,s)?distinct raze distinct'[x c]]; @[x;c;s?]}
denum:{$[0h=t:abs type x;.z.s'[x];t<20h;x;t<78h;get x;t=98h;@[x;where type'[flip x]within 20 77h;get];t=99h;!/[.z.s'[(key;get)@\:x]];x]}
day:{`Sat`Sun`Mon`Tue`Wed`Thu`Fri x mod 7}
dayname:{`Saturday`Sunday`Monday`Tuesday`Wednesday`Thursday`Friday x mod 7}
weekday:{$[0>type x;`$" "sv(string day x;ssr[-5#string x;".";"/"]);.z.s each x]}
across:{$[11h=t:type y;(0N,x)#y,$[n:count[y]mod x;x-n;0]#`; .Q.qt y; .z.s[x]first 0!y; t=99h; .z.s[x]`$string[key y],'" ",'-3!'get denum y; '`domain]}
comma:{$[0>t:type x; ((x<0)#"-"),","sv where[neg[n mod 3]rotate(n:count s)#100b]_s:string abs $[t in -5 -6 -7h;x;t in -8 -9h;"j"$x;'`domain]; .z.s each x]}
digits:{first system'[("P";"P ",string x)]}
sleep:{system" "sv(which`sleep;string"i"$"v"$x)}
col:{xcol[c^!/[(x;y),\:()]c:cols z;z]}
moveleft:{.Q.ft[{xcols[(min[c?x]#c:cols y),x]y}x]y}
moveright:{.Q.ft[{xcols[except[max[c?x]#c:cols y;x],x]y}x]y}
datebound:{$[14h~t:type x:(min;max)@\:x; x; t~13h; 0 -1+"d"$x+0 1; any t~/:5 6 7h; 0 -1+"d"$0 12+"m"$12*x-2000; '"Undefined date range"]}
pricedate:{[f;k;d] {[f;k;x;d]@[x;f[d]k;:;d]}[f;k]/[()!();d-reverse til 7]}
nullinf:{w:(min;first)@\:0#x; $[0>t:type x; $[w[0]~abs x;w 1;x]; t>0; @[x;where w[0]=abs x;:;w 1]; '`type]}
partfail:{x where not(x?x)=til count x@:where not(=':)x}
ypmatch:{update`$addr,host:alias 0,1_alias from update alias:`$" "vs trim host from`addr`host!"\t"vs first system" "sv(which`ypmatch;string x;"hosts")}

soundex:{d:"AEHIOUWYBFPVCGJKQSXZDTLMNR"!"00000000111122222222334556";
 f:{$[count y@:i:where not" "=y;x[i 0],3#(y where not "0"=y@:where 0b,1_differ y),"000";""]};
 `$$[type c:d x:upper$[type[x]in 0 10h;x;string x];f[x;c];f'[x;c]]}

logfiles:{x:$[x in(`;`:;::;());data`logs;x]; select host:h,job:(first` vs last` vs)'[f],file:f from ungroup([](last` vs)'[h];f:files'[h:dirs x])where f like"*.log"}

memory:{Memory,:`time`note xcols flip update time:1#.z.P,note:{enlist $[10h=type x; x; null x; ""; string x]}x from .Q.w[]}

slave:{
 system" "sv(which`ssh;"-q";h:string x;which`nohup;getenv`Q;"-p";p:string y;"1>/dev/null 2>&1&");
 system which[`sleep]," .5";
 @[hopen;`$":"sv("";h;p);0i]}

/ ------------------------------------------------------------------------------------------------------------------
/ functions for deriving dependencies and evaluation order from map of column expressions
/ ------------------------------------------------------------------------------------------------------------------
/  colmap: derive column names from expressions
/  depend: derive levels of evaluation, first level are base columns, then expressions derived from columns
/ subtree: given map and subset of columns, return dependency map required for subset
/ ------------------------------------------------------------------------------------------------------------------
colmap:{{raze over{$[-11h=t:type x;x;t;();.z.s each x]}x}'[x]}
depend:{(except':){y,where all each(y _x)in y}[x]\[a where not(a:distinct raze x)in key x]}
subtree:{(key[x]inter raze{raze x y}[x]\[y])#x}

/ --------------------------------------------------------------------------------------------------------------------
/  mysql access functions
/ --------------------------------------------------------------------------------------------------------------------
/    mysql1: enclose sql in single quotes after replacing embedded single quote with double, file -> 'source file'
/    mysql2: create system command string with config file, connection parameters and sql statement
/    mysql3: parse output from mysql command into q table given datatypes and output from system call
/    mysql:  execute mysql query given handle, column definitions, sql string/file name
/            h:`:host:port:user:pass
/            c: () to return as strings, single letter to return every column as one datatype, or column-specific
/            e.g. h:`:rfpoms1a:5029:costprod:omscost
/                 s:"select 'ibm' as s,1 as a,2.5 as b"
/                 mysql[h;();s]
/                 mysql[h;"*";s]
/                 mysql[h;"SIF";`:/some/file.sql]
/    mysqlf: as above, but no datatypes, handle & sql to execute cmd, write to file(via gzip if filename like *.gz)
/ mysqltrap: trap error, return 3 elements: flag,message,result  sucess:(1b;"";table)   error:(0b;message;())
/  mysqltry: try mysql/mysqlf n times, sleep s seconds using args given (designed for intermittent connection errors)
/            e.g. mysqltry[3; 5; h; "I"; "select count(*) from t"]
/ --------------------------------------------------------------------------------------------------------------------
mysql1:{"'", $[-11h=type x; "source ",1_string x; ssr[x;"'";"\""]], "'"}
mysql2:{
 s:(which`mysql; "--defaults-extra-file=",1_string path`sys`config`my.cnf);       /add config file w'login parameters
 s,:raze'[flip("-";count[v]#"hPup";v:":"vs 1_string $[x like":?*";x;source x])];  /allow :host:port[:user:pass] or tag
 " "sv s, ("-B";  "-e"; mysql1 y)}                                                /bulk format, string/input file to execute
mysql3:{$[0=count y; (); ($[10h=t:type x;x;sum[1b,d=first y]#("*";x)t=-10h];1#d:"\t")0:y]}
mysql:{[h;c;s]mysql3[c;system mysql2[h]s]}
mysqlf:{[h;s;f]system"(",mysql2[h;s],raze[$[f like"*.gz";3;-1]#(" | ";which`gzip;" > '")],(1_string f),"' )"; f}
mysqltrap:{@[{(1b;"";x . y)}$[-11h=type z;mysqlf;mysql]; (x;y;z); {(0b;x;())}]}
mysqltry:{[n;s;x;y;z]i:0; while[(n>i+:1)&not b:first r:mysqltrap[x;y;z]; if[s;system which[`sleep]," ",string s]]; $[b;last r;'"MySQL error:  ",r 1]}
